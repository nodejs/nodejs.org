---
title: Про Node.js®
layout: about
---

# Про Node.js®

Node.js, асинхронне подієве середовище виконання JavaScript, створене будувати масштабовані мережеві застосунки. Наступний приклад «Hello World» може обробляти багато з'єднань одночасно. Після кожного з'єднання виконується функція зворотного виклику, а якщо робота для виконання відсутня, Node.js буде очікувати.

```cjs
const { createServer } = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

```mjs
import { createServer } from 'node:http';

const hostname = '127.0.0.1';
const port = 3000;

const server = createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Ця модель використовується на противагу поширенішій моделі, у якій використовуються потоки ОС. Така модель відносно неефективна та важка у використанні. Крім того, користувачі Node.js можуть не хвилюватися про дедлоки, оскільки тут немає блокувань. Майже жодна функція не виконує ввід-вивід безпосередньо, тому процеси не блокуються, за винятком тих випадків, коли ввід-вивід виконується синхронними методами стандартної бібліотеки Node.js. Завдяки відсутності блокувань доцільно створювати масштабовані системи в Node.js.

Якщо деякі терміни вам незрозумілі, ось повна стаття про
[блокувальні та неблокувальні виклики](/learn/asynchronous-work/overview-of-blocking-vs-non-blocking).

---

Node.js надихався системами [Event Machine](https://github.com/eventmachine/eventmachine) мови Ruby та [Twisted](https://twisted.org/) мови Python. Проте Node.js зводить подієву модель на новий рівень. Він представляє цикл подій як основу середовища виконання, а не як бібліотеку. В інших системах присутній блокувальний виклик, який починає цикл подій. Зазвичай поведінка визначається функціями зворотного виклику на початку скрипту, після чого відбувається блокувальний виклик, наприклад, `EventMachine::run()`. Node.js не має такого виклику, а просто запускає цикл подій після виконання ввідного скрипту і виходить із циклу, коли всі зворотні виклики були виконані. Така поведінка схожа з поведінкою браузерного JavaScript — цикл подій прихований від користувача.

HTTP є повноцінною частиною Node.js, розроблений з урахуванням потокової передачі даних і низької затримки. Це робить Node.js ідеальним варіантом для створення основи для веббібліотеки або фреймворку.

Те, що Node.js спроєктований без використання потоків, не означає, що ви не можете використовувати багато ядер у своєму середовищі. Дочірні процеси можна створити за допомогою нашого API [`child_process.fork()`](https://nodejs.org/api/child_process.html). Вони спроєктовані так, що з ними можна легко взаємодіяти. Модуль [`cluster`](https://nodejs.org/api/cluster.html) побудований на такому самому інтерфейсі, що дозволяє ділити сокети на багато процесів, аби збалансувати навантаження на ядра.
